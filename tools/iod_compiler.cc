#include <iostream>
#include <fstream>
#include <string>
#include <boost/regex.hpp>

std::string symbol_definition(std::string s, std::string name);

// Iod to C++14 compiler.
//
//    Simple but useful syntaxic sugar on top of C++14.
//
//    Access to a symbol:                  @symbol      translated to    s::_Symbol
//    Access to a member via a symbol:     o@symbol     translated to    s::_Symbol.member_access(o);
//    Call to a method via a symbol:       o@symbol(42) translated to    s::_Symbol.method_call(o, 42);
//
//    All the symbols used in a C++ file are declared at the beginning of the generated file.
//
int main(int argc, char* argv[])
{
  using namespace std;

  if (argc != 3)
  {
    cout << "Usage: " << argv[0] << " input_iod_cpp_file output_cpp_file" << endl;
    return 1;
  }

  ifstream f(argv[1]);
  if (!f)
  {
    std::cerr << "Cannot open file " << argv[1] << " for reading." << std::endl;
    return 1;
  }
  
  set<string> symbols;
  set<string> symbols_already_defined;

  //  prefix identifier @ symbol_identifier (
  boost::regex symbol_regex("([[:alnum:]_]*)([[:blank:]]*)@[[:blank:]]*([[:alnum:]_]+)[[:blank:]]*(([(][[:blank:]]*[)]?)?)");
  // Matches:
  // 1: variable name
  // 2: spaces
  // 3: symbol
  // 4: parenthesis
  
  vector<string> lines;

  auto to_safe_alias = [] (string s) {
    return string("_") + s;
  };
  
  std::string line;
  bool in_raw_string = false;
  while (!f.eof())
  {
    getline(f, line);

    std::vector<int> dbl_quotes_pos;
    bool escaped = false;
    for (int i = 0; i < line.size(); i++)
    {
      if (line[i] == '"' and !escaped) dbl_quotes_pos.push_back(i);
      else if (line[i] == '\\') escaped = !escaped;
      else escaped = false;
    }

    auto is_in_string = [&] (int p) {
      int i = 0;
      while (i < dbl_quotes_pos.size() and dbl_quotes_pos[i] <= p) i++;
      return i % 2;
    };
    
    auto fmt = [&] (const boost::smatch& s) -> std::string {
      if (is_in_string(s.position())) return s[0];
      else
      {
        std::string symbol, variable_name, parenthesis;
        variable_name = s[1];
        string spaces = s[2];
        symbol = s[3]; 
        parenthesis = s[4];
        symbols.insert(symbol);
        ostringstream ss;

        if (variable_name.length() > 0)
        {
          ss << "s::" << to_safe_alias(symbol);
          if (parenthesis.length())
          {
            ss << ".method_call(" << variable_name;
            if (parenthesis.back() == ')') ss << ")";
            else ss << ", ";
          }
          else
            ss << ".member_access(" << variable_name << ")";
        }
        else ss << spaces << "s::" << to_safe_alias(symbol) << parenthesis;

        return ss.str();
      }
    };

    line = boost::regex_replace(line, symbol_regex, fmt);
    lines.push_back(line);


    // Check for symbols already defined.
    {
      boost::regex sab(".*namespace s { struct ([A-Za-z0-9_]+)_t.*");
      boost::smatch what;
      if (boost::regex_match(line, what, sab))
      {
        symbols_already_defined.insert(what[1]);
      }
    }

  }

  std::ofstream os(argv[2]);
  if (!os)
  {
    std::cerr << "Cannot open file " << argv[2] << " for writting." << std::endl;
    return 2;
  }

  os << "// Generated by the iod compiler."  << endl;
  std::stringstream symbols_content;
  //os << "#include <iod/symbol.hh>" << endl;
  for (string s : symbols)
  {
    std::string safe_alias = to_safe_alias(s);
    if (symbols_already_defined.find(safe_alias) == symbols_already_defined.end())
      symbols_content << symbol_definition(s, safe_alias) << endl;
  }

  int i = 1;
  for (auto line : lines)
  {
    if (line == "int __compiler_insert_symbols_here__();")
      os << symbols_content.str() << endl;
    else
      os << line << endl;
    i++;
  }
}

std::string symbol_definition(std::string s, std::string name)
{
  std::string body = R"definition(
namespace s { struct __N___t : iod::symbol<__N___t> { constexpr __N___t() {} typedef iod::symbol<__N___t> super; using super::operator=; inline const char* name() const { return "__S__"; } template <typename T> inline const auto& member_access(const T& o) const { return o.__S__; } template <typename T> inline auto& member_access(T& o) const { return o.__S__; } template <typename T, typename... A> inline auto method_call(const T& o, A... args) const { return o.__S__(args...); } template <typename T, typename INFO = iod::sio<>> struct variable_type : public iod::variable<variable_type<T, INFO>> { typedef T value_type; typedef INFO attributes_type; typedef __N___t symbol_type; variable_type() {} template <typename V> variable_type(V v) : __S__(v) {} inline value_type& value() { return __S__; } inline const value_type& value() const { return __S__; } auto symbol() const { return __N___t(); } auto symbol_name() const { return "__S__"; } auto attributes() const { return INFO(); } value_type __S__; }; }; constexpr __N___t __N__; }
)definition";

  boost::regex s_regex("__S__");
  boost::regex n_regex("__N__");
  body = boost::regex_replace(body, s_regex, s);
  body = boost::regex_replace(body, n_regex, name);

  return body;
}
